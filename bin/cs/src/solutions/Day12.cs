// Generated by Haxe 4.1.2

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace solutions {
	public class Day12 : global::haxe.lang.HxObject {
		
		static Day12() {
			unchecked{
				global::solutions.Day12.input = global::sys.io.File.getContent("E:/Mila/Documents/GitHub/adventofcode2020/src/inputs/Day12.txt");
				global::solutions.Day12.facings = new global::Array<string>(new string[]{"N", "E", "S", "W"});
				global::solutions.Day12.currFacing = 1;
				global::solutions.Day12.waypointX = 10;
				global::solutions.Day12.waypointY = 1;
			}
		}
		
		
		public Day12(global::haxe.lang.EmptyObject empty) {
		}
		
		
		public Day12() {
			global::solutions.Day12.__hx_ctor_solutions_Day12(this);
		}
		
		
		protected static void __hx_ctor_solutions_Day12(global::solutions.Day12 __hx_this) {
		}
		
		
		public static string input;
		
		public static global::Array<string> facings;
		
		public static int currFacing;
		
		public static int x;
		
		public static int y;
		
		public static int waypointX;
		
		public static int waypointY;
		
		public static void solve() {
			global::System.Console.WriteLine(((object) ("Solving Day12") ));
			global::Array<string> arr = global::haxe.lang.StringExt.split(global::solutions.Day12.input, "\r\n");
			{
				int _g = 0;
				while (( _g < arr.length )) {
					string instruction = arr[_g];
					 ++ _g;
					global::solutions.Day12.runInstruction(instruction);
				}
				
			}
			
			global::System.Console.WriteLine(((object) (global::haxe.lang.Runtime.concat("a: ", global::haxe.lang.Runtime.toString((( global::System.Math.Abs(((double) (global::solutions.Day12.x) )) + global::System.Math.Abs(((double) (global::solutions.Day12.y) )) ))))) ));
			global::solutions.Day12.x = 0;
			global::solutions.Day12.y = 0;
			{
				int _g1 = 0;
				while (( _g1 < arr.length )) {
					string instruction1 = arr[_g1];
					 ++ _g1;
					global::solutions.Day12.runWaypointInstruction(instruction1);
				}
				
			}
			
			global::System.Console.WriteLine(((object) (global::haxe.lang.Runtime.concat("b: ", global::haxe.lang.Runtime.toString((( global::System.Math.Abs(((double) (global::solutions.Day12.x) )) + global::System.Math.Abs(((double) (global::solutions.Day12.y) )) ))))) ));
		}
		
		
		public static void runWaypointInstruction(string instruction) {
			unchecked {
				global::haxe.lang.Null<int> @value = global::Std.parseInt(global::haxe.lang.StringExt.substr(instruction, 1, default(global::haxe.lang.Null<int>)));
				switch (global::haxe.lang.StringExt.charAt(instruction, 0)) {
					case "E":
					{
						global::solutions.Day12.moveWaypoint("E", (@value).@value);
						break;
					}
					
					
					case "F":
					{
						int _g = 0;
						global::haxe.lang.Null<int> _g1 = @value;
						while (( _g < (_g1).@value )) {
							int i = _g++;
							global::solutions.Day12.moveToWaypoint();
						}
						
						break;
					}
					
					
					case "L":
					{
						int _g2 = 0;
						int _g3 = ( (@value).@value / 90 );
						while (( _g2 < _g3 )) {
							int i1 = _g2++;
							global::solutions.Day12.rotateWaypoint("L");
						}
						
						break;
					}
					
					
					case "N":
					{
						global::solutions.Day12.moveWaypoint("N", (@value).@value);
						break;
					}
					
					
					case "R":
					{
						int _g4 = 0;
						int _g5 = ( (@value).@value / 90 );
						while (( _g4 < _g5 )) {
							int i2 = _g4++;
							global::solutions.Day12.rotateWaypoint("R");
						}
						
						break;
					}
					
					
					case "S":
					{
						global::solutions.Day12.moveWaypoint("S", (@value).@value);
						break;
					}
					
					
					case "W":
					{
						global::solutions.Day12.moveWaypoint("W", (@value).@value);
						break;
					}
					
					
					default:
					{
						global::System.Console.WriteLine(((object) ("Unhandled char found in instruction") ));
						break;
					}
					
				}
				
			}
		}
		
		
		public static void moveWaypoint(string direction, int @value) {
			switch (direction) {
				case "E":
				{
					global::solutions.Day12.waypointX += @value;
					break;
				}
				
				
				case "N":
				{
					global::solutions.Day12.waypointY += @value;
					break;
				}
				
				
				case "S":
				{
					global::solutions.Day12.waypointY -= @value;
					break;
				}
				
				
				case "W":
				{
					global::solutions.Day12.waypointX -= @value;
					break;
				}
				
				
				default:
				{
					global::System.Console.WriteLine(((object) (global::haxe.lang.Runtime.concat("Unhandled char found in move waypoint direction: ", direction)) ));
					break;
				}
				
			}
			
		}
		
		
		public static void rotateWaypoint(string direction) {
			if (( direction == "L" )) {
				int temp = global::solutions.Day12.waypointX;
				global::solutions.Day12.waypointX =  - (global::solutions.Day12.waypointY) ;
				global::solutions.Day12.waypointY = temp;
			}
			else if (( direction == "R" )) {
				int temp1 = global::solutions.Day12.waypointX;
				global::solutions.Day12.waypointX = global::solutions.Day12.waypointY;
				global::solutions.Day12.waypointY =  - (temp1) ;
			}
			
		}
		
		
		public static void moveToWaypoint() {
			global::solutions.Day12.x += global::solutions.Day12.waypointX;
			global::solutions.Day12.y += global::solutions.Day12.waypointY;
		}
		
		
		public static void runInstruction(string instruction) {
			unchecked {
				global::haxe.lang.Null<int> @value = global::Std.parseInt(global::haxe.lang.StringExt.substr(instruction, 1, default(global::haxe.lang.Null<int>)));
				switch (global::haxe.lang.StringExt.charAt(instruction, 0)) {
					case "E":
					{
						global::solutions.Day12.move("E", (@value).@value);
						break;
					}
					
					
					case "F":
					{
						global::solutions.Day12.move(global::solutions.Day12.facings[global::solutions.Day12.currFacing], (@value).@value);
						break;
					}
					
					
					case "L":
					{
						global::solutions.Day12.currFacing = ( (( ( global::solutions.Day12.currFacing + 4 ) - ( (@value).@value / 90 ) )) % 4 );
						break;
					}
					
					
					case "N":
					{
						global::solutions.Day12.move("N", (@value).@value);
						break;
					}
					
					
					case "R":
					{
						global::solutions.Day12.currFacing = ( (( global::solutions.Day12.currFacing + ( (@value).@value / 90 ) )) % 4 );
						break;
					}
					
					
					case "S":
					{
						global::solutions.Day12.move("S", (@value).@value);
						break;
					}
					
					
					case "W":
					{
						global::solutions.Day12.move("W", (@value).@value);
						break;
					}
					
					
					default:
					{
						global::System.Console.WriteLine(((object) ("Unhandled char found in instruction") ));
						break;
					}
					
				}
				
			}
		}
		
		
		public static void move(string direction, int @value) {
			switch (direction) {
				case "E":
				{
					global::solutions.Day12.x += @value;
					break;
				}
				
				
				case "N":
				{
					global::solutions.Day12.y += @value;
					break;
				}
				
				
				case "S":
				{
					global::solutions.Day12.y -= @value;
					break;
				}
				
				
				case "W":
				{
					global::solutions.Day12.x -= @value;
					break;
				}
				
				
				default:
				{
					global::System.Console.WriteLine(((object) (global::haxe.lang.Runtime.concat("Unhandled char found in move direction: ", direction)) ));
					break;
				}
				
			}
			
		}
		
		
	}
}


